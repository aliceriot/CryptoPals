#Matasano exercise 06

This is a literate Python explanation of my solution to the
[sixth](http://cryptopals.com/sets/1/challenges/6/) Matasano problem. Here we
have a message which has been encrypted with repeating-key XOR (which is, more
or less, the Vigenere's cipher). It's encoded in Base64, and we want to figure
out how to read it! Great! How do?

Well, actually the Matasano folks give us a really nice explanation of how to
proceed. Basically I'm going to take their overview, modify it somewhat, and
intersperse the code that performs that step. Cool!

First off, we'll read in the ciphertext:

<<>>=
from base64 import b64decode

with open("./ex06.txt") as f:
    ciphertext = b64decode(''.join([l.strip() for l in f.readlines()]))
@

We read in the file line-by-line, strip off newlines, and join all the
cleaned lines together. The `b64decode` function returns a `bytes` object.

##KEYSIZE

Keysize is the length of the key. Since this is the repeating-key XOR
cryptosystem this is basically the number of bytes in a key. A message is
encrypted by XORing character `i` with `key[i % keysize]`, so for a keysize of
4 the fourth, eighth, twelfth, and so on characters will all be XORed with
the fourth byte of the key (and same for the first, fifth, ninth, etc.
with the first byte of the key).

Matasano lets us know that we only have to worry about keysize ranging between
2 and 40 (they're so helpful with the hints sometimes!). So we'll need some way
to figure out the most appropriate keysize - once we know that we can get to
the business of figuring out the key.

##Hamming Distance

Hamming distance is a metric for *string difference*, and in this case we want
to essentially count the number of bits where two strings (C-style bytestrings)
are different.

Here's a little function to do that:

<<>>=
def distance(s1, s2):
    return sum(bin(x^y).count('1') for x,y in zip(s1,s2))
@

Ok, so we zip string one and string two together, then we XOR them (which
will leave ones wherever they differ), use `bin` to get a string
representation of that, and then count the number of ones. If we sum this
across `zip(s1,s2)` we get our difference. Nice!

##Finding the right KEYSIZE

OK, now that we've defined the Hamming distance, we can use that to find
an appropriate keysize with which to move forward. Basically, we expect
that if we have the right keysize, then if we chunk the ciphertext into
blocks of `keysize` length, we should see a lower Hamming distance between
those chunks than we would between chunks of a randomly selected length.
This is because if we have `keysize` correct, then those chunks will have
been XORed against the same block, and so will have that in common. Great!

This is a class named `Keysieve` which does this for us:

<<>>=
from statistics import mean

class Keysieve(object):
    def __init__(self, ciphertext, minkey, maxkey):
        self.scores = []
        self.keys = range(minkey, maxkey + 1)
        self.ctext = ciphertext
        self.sieve()

    def sieve(self):
        for ksize in self.keys:
            first = self.ctext[:ksize]
            chunks = [self.ctext[i*ksize:(i+1)*ksize] for i in range(10)]
            scores = [distance(first, i)/ksize for i in chunks]
            self.scores.append((ksize, mean(scores)))
        self.scores.sort(key = lambda x: x[1])
@

The constructor for `Keysieve` takes a minkey and a maxkey, which are the
bounds on our keysize search space. We also need to have a ciphertext to
work on.

Lets instantiate a `Keysieve` object now:

<<>>=
keysieve = Keysieve(ciphertext, 2,40)
@

Great! When we instantiate the object the `sieve` method gets called
automatically. This is going to iterate through the possible keysizes and,
for each one, calculate the average pairwise Hamming distance between the
first chunk of size `keysize` and all other chunks. We assume that the
keysize that results in the lowest score will be our winner, so then we
call the `sort` method on `keysieve.scores`.

Then we can get our putative best keysize by doing:

<<>>=
keysize = keysieve.scores[0][0]
@

##Breaking up the Ciphertext

Now that we know the `keysize` we can get on with solving the problem.
First we want to split the ciphertext up into `keysize` different blocks,
where each block is composed of the bytes in the ciphertext whose
remainder modulo `keysize` is a particular number. So there will be
a block of all those bytes whose index modulo `keysize` is 0, all those
whose index modulo `keysize` is 1, and so on, up to `keysize -1`.

Then we have a block which is constructed from the first byte from every
`keysize` chunk, the second byte from every `keysize` chunk, and so on.
Then we can take those blocks and, since they've all been XORed with the
same byte of the key, we can solve them each independently as if they were
separate ciphertexts encrypted with single byte XOR. Great!

###Making the blocks

Here's how we'll make the blocks (naturally, with a class called
`Blocks`):

<<>>=
class Blocks(object):
    """takes ciphertext and best keysizes, makes blocks"""
    def __init__(self, ciphertext, keysize):
        self.ciphertext = ciphertext
        self.keysize = keysize
        self.blocks = [[] for i in range(self.keysize)]
        self.blockify()

    def blockify(self):
        for tup in enumerate(self.ciphertext):
            self.blocks[tup[0] % self.keysize].append(tup[1])
        map(bytearray, self.blocks)
@

Now we can make the blocks! Weee!

<<>>=
blocks = Blocks(ciphertext, keysize)
@


